% Chapter 4

\chapter{Conclusioni} % Main chapter title

\label{Conclusioni} % For referencing the chapter elsewhere, use \ref{Chapter1} 

\lhead{\emph{Conclusioni}} % This is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------

I risultati ottenuti dalle simulazioni effettuate mediante
l'utilizzo dell'algoritmo implementato in CUDA, messi a confronto con i
risultati del medesimo algoritmo codificato in Python, hanno confermato
la correttezza dell'algoritmo CUDA. Differentemente dalla versione Python, che fa uso di una
struttura a stack più intuitiva da implementare e gestire,
l'algoritmo CUDA utilizza una struttura dati ad albero
per l'elaborazione della simulazione. La scelta di questo tipo di strutture 
ad albero ha portato un enorme
vantaggio in termini prestazionali, poiché: la scelta di implementare
una soluzione che prevedesse l'utilizzo del parallelismo dinamico ha permesso di
verificare la validità di questa metodologia nella simulazione di fenomeni
intrinsecamente ricorsivi. Il parallelismo dinamico con molti livelli
di profondità risulta quindi un'ottima soluzione quando si tratta di elaborare
strutture dati predisposte alla ricorsione, come in questo caso. Sebbene CUDA
preveda un limite fisico al numero di livelli di ricorsione disponibili, è
degna di nota l'accelerazione fornita alla simulazione.
Gli sviluppi futuri prevedono, a fronte della crescita esponenziale della 
popolazione cellulare, l'ottimizzazione dell'utilizzo della memoria 
tramite l'implementazione di tecniche per la gestione di un numero 
di GPU superiore ad uno. Così facendo, sarebbe possibile demandare la computazione 
di sottopopolazioni cellulari ognuna ad una GPU dedicata, incrementando 
ulteriormente le performance del simulatore. Inoltre, sarebbe interessante 
analizzare lo speedup a fronte di una popolazione iniziale $X_{0}$ con 
numerosità estremamente maggiore di quella utilizzata per le simulazioni 
riportate nella Sezione \ref{sec:performance}, approssimativamente di $5*10^4$
cellule. Infine, si potrebbero utilizzare strutture dati
differenti dagli array per rappresentare un insieme di alberi di 
proliferazione; ad esempio sarebbe possibile implementare una matrice per 
rappresentare la totalità delle popolazioni cellulari necessarie allo sviluppo 
della simulazione. CUDA si presta bene anche al calcolo di questo tipo di 
strutture, poiché è possibile suddividere un kernel in blocchi sia 
bidimensionali che tridimensionali, e procedere dunque all'elaborazione 
parallela di diverse popolazioni cellulari.
Questo metodo però accentuerebbe maggiormente il problema di gestione della 
memoria, poiché si dovrebbe allocare uno spazio di memoria all'interno della 
GPU sufficiente a memorizzare una matrice di dimensioni $n * |X_{n}|$, con 
$n$ uguale al numero massimo di livelli degli alberi di proliferazione, 
richiedendo inutilmente risorse per la computazione di cellule non 
facenti parte della popolazione considerata, dato che la popolazione $X_{0}$ 
sarebbe composta da un numero esponenzialmente inferiore di cellule rispetto 
alla popolazione finale $X_{n}$. Dunque la ricerca e 
l'analisi di strutture dati adatte a rappresentare questa tipologia di 
fenomeni potrebbe influire notevolmente sulle performance del simulatore.
